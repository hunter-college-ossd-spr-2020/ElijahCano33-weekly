---
layout: post
title: Week 12
---

# Gatsby Chronicles & Issue Analysis: :mag:

This past week I have done a lot research on a few particular Gatsby issues that I have been interested in. Last week I mentioned an issue in my blog that seemed interesting, but I had doubts about it. The issue was concerned with helping the Gatsby team continue to flesh out all their gatsby-node-api function descriptions. The Gatsby team currently feels as though there is still a lot of confusion relating to their gatsby-node api functions and because of this they are looking for someone to go through all of gastby-node api functions and add further context about each one and include important information about each api function such as what parameters it is expecting to be passed into it as well as an example detailing how to actually use it. I expressed interest, but I had doubts simply for the fact that I personally didn't feel that I had the necessary experience with these api functions to actually be able to really flesh them out in a way where I could really help others comprehend it very well. Nevertheless, I still decided to attempt to see if I could do it. I didn't request to work on it because I prefer to work on the task locally first and get a sense of it to see if I can actually complete before I notify the Gatsby team to see if I can work on it. I began working on it and for some of the api functions it is somewhat easy to identify the exact parameters and what exactly those parameters are supposed to be, but for others it is also not so easy to understand unless you have experience using them. For example, with the onCreateDevServer api function the parameter is very easy to identify, it's trivial to understand that it's the express app that's used to make requests to the server as well as run it, but for other ones such as the createPagesStatefully api function the parameters are not easy to identify nor is it clear what those parameters are really supposed to be. Gatsby does provide a link alongisde these api functions to their location in the index.js file in their source code, but even there it's not super clear how everything works for that api function. As a result of this, I decided to not request to work on this issue simply because I feel that this issue would be a better fit for someone who has more experience using these apis.

Another issue that I looked into was this [one](https://github.com/gatsbyjs/gatsby/issues/23421). This issue was concerned with two outdated versions for the dependency libraries called puppeteer and puppeteer-core within the Gatsby project. The person that opened up the issue is requesting that the versions for these two depencies be updated to the latest version because the primary version that is being used by the Gatsby team is version 1.20.0 for puppeteer and version 2.1.0 for puppeteer-core and these versions are outdated as the latest version for both seems to be 3.0.2. Initially, I thought this was a good issue to work on so I decided to do some research about the latest version of puppeteer and what changes have been made since version 1.20.0. Of course, with a very mature project such as Gatsby, you have to be very careful when updating packages from very outdated versions to the newest and latest version because those new latest version can have tons of large changes and possibly break a ton of stuff since the code that was implemented with the outdated version of the package may no longer work with the new and latest version. I began doing some research within the Gatsby project to see all the places where puppeteer is being used, and it appears that both puppeteer and puppeteer-core are only being used in a very select amount of places within the Gatsby project. I thought that was great because that potentially means that the risk of breaking a lot of stuff from updating the outdate version of the package to the latest version would be extremely minimal. Along with this, I also decided to go to the package's pages to see exactly what new features and changes have been made from version to version. Upon analyzing this information, I discovered that the new versions specifially those past version 3.0.0 rely on Node 10.18.1+. I checked the Gatsby project to see what version of Node they are running to see that they are currently supporting all version of node that are greater than or equal to 8.0.0. 

# Response to Tom Callaways's Blog Post Concerning Business Models in Open Source:
Tom Callaway's blog post is short and very straight to the point. In his blog post, he begins by listing out the different business models companies participating in the open source space have and how each model essentially works. Following from that, he mentions and makes the case that creating proprietary software and selling that software is a very straightforward business model which I do completely agree with. He utters that in this model the company simply makes software and just hires developers to both maintain and continue adding new features here and there to the already existing software. This is different compared to an open source business model where it is not just the hired developers who are maintaining and able to add new features to the software, but also the client, partners, and possibly even competitors. Tom continues to assert that because customers, partners, and even competitors are able to contribute to the actual software that this is even more beneficial and advantageous to the software than just having a select amount of hired developers solely work on the software and maintain it. He also argues that because clients have more control and transparency of the software that they using that they tend to be happier and more engaged with the company that has ownership of the software. 

I think his points are interesting, but I also think he is not taking into consideration any of the negatives that can possibly come with making a product open source. Yes, it is true that clients, partners, and competitors do have the ability to contribute and work on the software too, but one could most certainly make the case that this could be a bad thing for the company in some regards. First, with a developer team that has been hired, trained, and is much more familiar with the codebase one can make the case that the continued development and enchancement of the software will be much faster than having the product be open sourced because clients, partners, and competitors won't be as experienced with the code base that the hired team would be. The development process could be slower because there could be an extremely high learning curve for every client, partner, or competitor that wants to learn the inner workings of the software product and ultimately contribute. Slower development process could be bad depending on the product and where it is at currently. Also, everyone that has been hired to work and maintain the software most likey has gone through some sort of screening/interview process by the company to verify whether or not they are a fit for the job. When you make a product open source and welcome people to come and contribute, odds are most of the time you won't really know who that person is that requested to help fix a particular issue with the software. Becasue of this, there is a lot of uncertainty concerning whether or not the person wanting to contribute has the appropriate experience, knowledge of the codebase, etc... If that person is inexperienced, it could slow down the development process, but maybe they might be very experienced, and actually do more than what was expected. 

Also, in regards to customer satisfaction, one could make the argument that having a product be open sourced doesn't necessarily make the client more happy with the product or the company, and that customer satisfaction is all relative and depends really on the product and what needs of the client it's fulfilling. A product could have everything already that a client might want and be perfect. It all really depends. All in all, I am not disagreeing with any of Tom's points, but I am just saying that arguments could also be made for the opposing side and that I think he should consider them because compelling arguments could be made from both sides!